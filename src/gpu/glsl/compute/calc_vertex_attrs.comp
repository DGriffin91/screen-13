// NOTE: This program is intended to help "inflate" model vertex buffers which have been read from
// disk or the network. We do not store normal or tangent in the asset .pak file, so these
// attributes must be reconstructed at runtime; prior to rendering use.

#version 450

const uint DST_STRIDE = 36;
const uint SRC_STRIDE = 15;

struct Vertex {
    vec3 position;
    vec2 texcoord;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    layout(offset = 0) uint offset;
} push_constants;

layout(set = 0, binding = 0, std430) restrict readonly buffer SrcBuffer {
    float src_buf[];
};

layout(set = 0, binding = 1, std430) restrict writeonly buffer DstBuffer {
    float dst_buf[];
};

Vertex read(uint idx) {
    float x = src_buf[idx];
    float y = src_buf[++idx];
    float z = src_buf[++idx];
    float u = src_buf[++idx];
    float v = src_buf[++idx];
    vec3 position = vec3(x, y, z);
    vec2 texcoord = vec2(u, v);

    return Vertex(position, texcoord);
}

void write(Vertex vertex, vec3 normal, vec4 tangent, uint idx) {
    dst_buf[idx] = vertex.position.x;
    dst_buf[++idx] = vertex.position.y;
    dst_buf[++idx] = vertex.position.z;
    dst_buf[++idx] = normal.x;
    dst_buf[++idx] = normal.y;
    dst_buf[++idx] = normal.z;
    dst_buf[++idx] = tangent.x;
    dst_buf[++idx] = tangent.y;
    dst_buf[++idx] = tangent.z;
    dst_buf[++idx] = tangent.w;
    dst_buf[++idx] = vertex.texcoord.x;
    dst_buf[++idx] = vertex.texcoord.y;
}

void main() {
    // Read three vertices of a triangle from the source
    uint src_idx = push_constants.offset + gl_GlobalInvocationID.x * SRC_STRIDE;
    Vertex a = read(src_idx);
    Vertex b = read(src_idx + 5);
    Vertex c = read(src_idx + 10);

    // Calculate the normal of the front face of this triangle
    vec3 ba = b.position - a.position;
    vec3 ca = c.position - a.position;
    vec3 normal = normalize(cross(ba, ca));

    // Calculate the four-component tangent (with handedness)
    vec2 s = b.texcoord - a.texcoord;
    vec2 t = b.texcoord - a.texcoord;
    float r = 1 / (s.x * t.y - t.x * s.y);
    vec3 s_dir = r * vec3((t.y * ba.x - s.y * ca.x),
                          (t.y * ba.y - s.y * ca.y),
                          (t.y * ba.z - s.y * ca.z));
    vec3 t_dir = r * vec3((s.x * ca.x - t.x * ba.x),
                          (s.x * ca.y - t.x * ba.y),
                          (s.x * ca.z - t.x * ba.z));
    vec4 tangent = vec4(
        normalize(s_dir - normal * dot(normal, s_dir)),
        dot(cross(normal, s_dir), t_dir) >= 0 ? 1 : -1
    );

    // Write the (larger) output vertices for one triangle
    uint dst_idx = push_constants.offset + gl_GlobalInvocationID.x * DST_STRIDE;
    write(a, normal, tangent, dst_idx);
    write(b, normal, tangent, dst_idx + 12);
    write(c, normal, tangent, dst_idx + 24);
}
